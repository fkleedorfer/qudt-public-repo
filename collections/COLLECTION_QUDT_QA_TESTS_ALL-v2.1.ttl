# baseURI: http://qudt.org/2.1/collection/qa/all
# imports: http://qudt.org/2.1/vocab/constant
# imports: http://qudt.org/2.1/vocab/mathematics
# imports: http://qudt.org/2.1/vocab/soqk

@prefix creativecommons: <http://creativecommons.org/ns#> .
@prefix dc: <http://purl.org/dc/elements/1.1/> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix qkdv: <http://qudt.org/vocab/dimensionvector/> .
@prefix quantitykind: <http://qudt.org/vocab/quantitykind/> .
@prefix qudt: <http://qudt.org/schema/qudt/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .
@prefix unit: <http://qudt.org/vocab/unit/> .
@prefix vaem: <http://www.linkedmodel.org/schema/vaem#> .
@prefix voag: <http://voag.linkedmodel.org/schema/voag#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

<http://qudt.org/2.1/collection/qa/all>
  a owl:Ontology ;
  rdfs:isDefinedBy <http://qudt.org/2.1/collection/qa/all> ;
  rdfs:label "QUDT Collection - QA TESTS - ALL - v 2.1.33" ;
  owl:imports <http://qudt.org/2.1/vocab/constant> ;
  owl:imports <http://qudt.org/2.1/vocab/mathematics> ;
  owl:imports <http://qudt.org/2.1/vocab/soqk> ;
  sh:declare [
      sh:namespace "http://qudt.org/schema/qudt/"^^xsd:anyURI ;
      sh:prefix "qudt" ;
    ] ;
  sh:declare [
      sh:namespace "http://www.w3.org/2002/07/owl#"^^xsd:anyURI ;
      sh:prefix "owl" ;
    ] ;
  sh:declare [
      sh:namespace "http://www.w3.org/2004/02/skos/core#"^^xsd:anyURI ;
      sh:prefix "skos" ;
    ] ;
  sh:declare [
      sh:namespace "http://www.w3.org/2001/XMLSchema#"^^xsd:anyURI ;
      sh:prefix "xsd" ;
    ] ;
.
qudt:QuantityKind
  sh:property [
      sh:path qudt:hasDimensionVector ;
      rdfs:comment "Check for inconsistent dimensionvectors in the skos:broader hierarchy" ;
      sh:sparql [
          a sh:SPARQLConstraint ;
          sh:message "{$this} has a dimension vector that is inconsistent with {?qk} in its skos:broader hierarchy." ;
          sh:prefixes <http://qudt.org/2.1/collection/qa/all> ;
          sh:select """
SELECT $this ?qk
WHERE {
$this qudt:hasDimensionVector  ?udv .
$this skos:broader* ?qk .
?qk qudt:hasDimensionVector ?qdv .
FILTER (?udv != ?qdv) .
}
""" ;
        ] ;
    ] ;
.
qudt:UnitShape
  sh:targetClass qudt:Unit;
    rdfs:comment "qudt:conversionMultiplier must match qudt:conversionMultiplierInScientificNotation if present" ;
    sh:sparql [
        a sh:SPARQLConstraint ;
        sh:minCount 1;
        sh:message "{$this} qudt:conversionMultiplier is {?actual}, which does not match {?expected}, m:{?m} e:{?e} mNoDot:{?mNoDot} mDigitCount:{?mDigitCount} exponent:{?exponent} startPos:{?startPos} high:{?highDigits} low:{?lowDigits} expected:{?expectedStringValue} result:{?result} " ;
        sh:prefixes <http://qudt.org/2.1/collection/qa/all> ;
        sh:select """
            SELECT $this ?actual ?expected ?m ?e ?exponent ?mNoDot ?mDigitCount ?startPos ?highDigits ?lowDigits ?expectedStringValue ?tmp ?result
            WHERE {
                # select both values
                $this
                    qudt:conversionMultiplier ?actual ;
                    qudt:conversionMultiplierInScientificNotation ?expected .
                BIND(REPLACE(STR(?expected), "[eE]-?\\\\d+$", "") as ?m)               # extract the mantissa (string)
                BIND(REPLACE(STR(?expected), "^\\\\d(\\\\.\\\\d+)?[eE]", "") as ?e)    # extract the exponent (string)
                BIND(REPLACE(STR(?m),"\\\\.","") AS ?mNoDot)                           # remove the comma from the mantissa
                BIND(STRLEN(?mNoDot) as ?mDigitCount)                                  # count the mantissa's characters
                BIND(xsd:integer(?e) as  ?exponent)                                    # cast e to an integer, called exponent
                # prepare a string with 200 zeros padding left and right, mantissa in the middle
                BIND(CONCAT(
                                    "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
                                    ?mNoDot,
                                    "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000") as ?baseStr)
                BIND(IF(?exponent > 0, 201, 200 + ?exponent + 1) as ?startPos)         # determine the start position for clipping
                BIND(IF(?exponent > 0, ?exponent + 1, 1) as ?highDigits)               # determine the number of digits before the comma
                # determine the number of digits after the comma
                BIND(IF(?exponent > 0, IF(?mDigitCount - ?exponent > 1, ?mDigitCount - ?exponent - 1, 1), ?mDigitCount - ?exponent - 1) as ?lowDigits)
                # determine the expected string
                BIND(CONCAT(SUBSTR(?baseStr, ?startPos, ?highDigits), ".", SUBSTR(?baseStr, ?startPos + ?highDigits, ?lowDigits)) as  ?expectedStringValue)
                # compare with actual
                BIND(IF(?expectedStringValue = STR(?actual), "match!", "no match!") as ?result)
                # only generate message if no match (useful during development)
                FILTER(?result != "match!")
            }
        """ ;
      ] ;


  sh:property [
      sh:path qudt:exactMatch ;
      rdfs:comment "Check for non-reciprocal owl:sameAs and qudt:exactMatch triples" ;
      sh:sparql [
          a sh:SPARQLConstraint ;
          sh:message "{$this} needs both owl:sameAs and qudt:exactMatch with {?y}" ;
          sh:prefixes <http://qudt.org/2.1/collection/qa/all> ;
          sh:select """
SELECT $this ?y
WHERE { GRAPH <http://qudt.org/2.1/vocab/unit> {
{
$this owl:sameAs ?y .
FILTER NOT EXISTS {$this qudt:exactMatch ?y} .
}
UNION
{
$this qudt:exactMatch ?y .
FILTER NOT EXISTS {$this owl:sameAs ?y} .
}
FILTER  ($this != ?y)
}}
""" ;
        ] ;
    ] ;
  sh:property [
      sh:path qudt:hasDimensionVector ;
      rdfs:comment "Check for inconsistent dimensionvectors from units and quantitykinds" ;
      sh:sparql [
          a sh:SPARQLConstraint ;
          sh:message "{$this} has a dimension vector that is inconsistent with its quantity kind, {?qk}" ;
          sh:prefixes <http://qudt.org/2.1/collection/qa/all> ;
          sh:select """
SELECT $this ?qk
WHERE {
$this qudt:hasDimensionVector  ?udv .
$this qudt:hasQuantityKind ?qk .
?qk qudt:hasDimensionVector ?qdv .
FILTER (?udv != ?qdv) .
}
""" ;
        ] ;
    ] ;
.
